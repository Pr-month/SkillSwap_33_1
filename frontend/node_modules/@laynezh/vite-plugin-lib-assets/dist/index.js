// src/index.ts
import fs4 from "fs";
import path3 from "path";
import { createFilter } from "vite";
import { interpolateName } from "loader-utils";

// src/utils.ts
import fs from "fs";
import path from "path";
import { version } from "vite";
import { gte } from "semver";
import * as mrmime from "mrmime";
import escapeStringRegexp from "escape-string-regexp";

// src/vitools.ts
function svgToDataURL(content) {
  const stringContent = content.toString();
  if (stringContent.includes("<text") || stringContent.includes("<foreignObject")) {
    return `data:image/svg+xml;base64,${content.toString("base64")}`;
  } else {
    return "data:image/svg+xml," + stringContent.trim().replaceAll(/>\s+</g, "><").replaceAll('"', "'").replaceAll("%", "%25").replaceAll("#", "%23").replaceAll("<", "%3c").replaceAll(">", "%3e").replaceAll(/\s+/g, "%20");
  }
}

// src/utils.ts
function isObject(value) {
  return Object.prototype.toString.call(value) === "[object Object]";
}
var intermidiateFormats = ["es", "cjs"];
var finalFormats = ["umd", "iife"];
function checkFormats(formats) {
  const isIntermidiateFormat = formats.some((format) => intermidiateFormats.includes(format));
  const isFinalFormat = formats.some((format) => finalFormats.includes(format));
  return Number(isIntermidiateFormat) + Number(isFinalFormat) === 1;
}
var assetsContentMap = /* @__PURE__ */ new Map();
function getAssetContent(id) {
  let content = assetsContentMap.get(id);
  const pureId = id.split("?")[0];
  if (!content) {
    if (!fs.existsSync(pureId)) {
      console.warn(`[vite-plugin-lib-assets]: file not found ${id}`);
      content = null;
    } else {
      content = fs.readFileSync(pureId);
      assetsContentMap.set(id, content);
    }
  }
  return content;
}
var postfixRE = /[?#].*$/s;
function cleanUrl(url) {
  return url.replace(postfixRE, "");
}
function registerCustomMime() {
  mrmime.mimes["ico"] = "image/x-icon";
  mrmime.mimes["cur"] = "image/x-icon";
  mrmime.mimes["flac"] = "audio/flac";
  mrmime.mimes["eot"] = "application/vnd.ms-fontobject";
  mrmime.mimes["jxl"] = "image/jxl";
}
function getFileBase64(id, content) {
  const file = cleanUrl(id);
  if (gte(version, "5.0.0") && file.endsWith(".svg")) {
    return svgToDataURL(content);
  } else {
    const mimeType = mrmime.lookup(file) ?? "application/octet-stream";
    return `data:${mimeType};base64,${content.toString("base64")}`;
  }
}
function getCaptured(input, re) {
  const captures = [];
  let match;
  let remaining = input;
  while (match = re.exec(remaining)) {
    match[1] !== void 0 && captures.push(match[1]);
    remaining = remaining.slice(match.index + match[0].length);
  }
  return captures;
}
function replaceAll(source, searchValue, replaceValue) {
  if (typeof source.replaceAll === "function")
    return source.replaceAll(searchValue, replaceValue);
  const escaped = escapeStringRegexp(searchValue);
  const replaceRegExp = new RegExp(escaped, "g");
  return source.replace(replaceRegExp, replaceValue);
}
var publicFileCache = /* @__PURE__ */ new Map();
function checkPublicAsset(source, publicDir) {
  if (!source.startsWith("/") || !publicDir)
    return false;
  const publicFile = path.posix.join(publicDir, source);
  if (publicFileCache.has(publicFile))
    return publicFileCache.get(publicFile);
  const exists = fs.existsSync(publicFile);
  if (exists)
    publicFileCache.set(publicFile, exists);
  return exists;
}

// src/constants.ts
var KNOWN_ASSET_TYPES = [
  // images
  "apng",
  "png",
  "jpe?g",
  "jfif",
  "pjpeg",
  "pjp",
  "gif",
  "svg",
  "ico",
  "webp",
  "avif",
  // media
  "mp4",
  "webm",
  "ogg",
  "mp3",
  "wav",
  "flac",
  "aac",
  "opus",
  // fonts
  "woff2?",
  "eot",
  "ttf",
  "otf",
  // other
  "webmanifest",
  "pdf",
  "txt"
];
var DEFAULT_ASSETS_RE = new RegExp(
  `\\.(${KNOWN_ASSET_TYPES.join("|")})(\\?.*)?$`
);
var JS_TYPES_RE = /\.(?:j|t)sx?$|\.mjs$/;
var CSS_LANGS_RE = /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/;
var assetImportMetaUrlRE = /\bnew\s+URL\s*\(\s*('[^']+'|"[^"]+"|`[^`]+`)\s*,\s*import\.meta\.url\s*(?:,\s*)?\)/g;
var cssUrlRE = /(?<=^|[^\w\-\u0080-\uFFFF])url\((\s*('[^']+'|"[^"]+")\s*|[^'")]+)\)/;
var cssImageSetRE = /(?<=image-set\()((?:[\w\-]{1,256}\([^)]*\)|[^)])*)(?=\))/;
var ASSETS_IMPORTER_RE = /\.(css|js|cjs|mjs)(?:$|\?)/;

// src/compiler.ts
import { createRequire } from "module";
function resolveCompiler(root) {
  const vueMeta = tryRequire("vue/package.json", root);
  const version2 = vueMeta ? vueMeta.version.split(".")[0] : "";
  const compiler = tryRequire("vue/compiler-sfc", root) || tryRequire("vue/compiler-sfc");
  if (!compiler) {
    throw new Error(
      "Failed to resolve vue/compiler-sfc.\nvite-plugin-vue-setup-name requires vue (>=2.7.0) to be present in the dependency tree."
    );
  }
  return { impl: compiler, version: version2 };
}
var _require = createRequire(import.meta.url);
function tryRequire(id, from) {
  try {
    return from ? _require(_require.resolve(id, { paths: [from] })) : _require(id);
  } catch (e) {
  }
}

// src/descriptorCache.ts
import fs2 from "fs";
function parseSFC(filename, source, { version: version2, impl: compiler }) {
  let result;
  if (version2 === "2") {
    let descriptor;
    let errors = [];
    try {
      descriptor = compiler.parse({ source, filename, sourceMap: false });
    } catch (e) {
      errors = [e];
      descriptor = compiler.parse({ source: "", filename });
    }
    result = { descriptor, errors };
  } else if (version2 === "3") {
    result = compiler.parse(source, { filename, sourceMap: false });
  } else {
    throw new Error("Unknown vue version");
  }
  return result;
}
function getDescriptor(filename, options, createIfNotFound = true) {
  if (createIfNotFound) {
    const { compiler } = options;
    const { descriptor, errors } = parseSFC(filename, fs2.readFileSync(filename, "utf-8"), compiler);
    if (errors.length)
      throw errors[0];
    return descriptor;
  }
}

// src/alias.ts
function matches(pattern, importee) {
  if (pattern instanceof RegExp)
    return pattern.test(importee);
  if (importee.length < pattern.length)
    return false;
  if (importee === pattern)
    return true;
  return importee.startsWith(`${pattern}/`);
}
async function resolve(context, alias, importees, importer) {
  const resolves = importees.map((importee) => {
    const matched = alias.find((alias2) => matches(alias2.find, importee));
    const updated = matched ? importee.replace(matched.find, matched.replacement) : importee;
    return context.resolve(updated, importer, { skipSelf: true }).then((resolved) => resolved !== null ? resolved.id : updated);
  });
  return Promise.all(resolves);
}

// src/processStyle/index.ts
import fs3 from "fs";
import path2 from "path";
import util from "util";
import { Buffer } from "buffer";
import { preprocessCSS } from "vite";
import escapeStringRegexp2 from "escape-string-regexp";

// src/processStyle/config.ts
async function ensureCssSourceMapConfig(config) {
  let css = config.css ?? {};
  let build = config.build ?? {};
  if ("transformer" in css && css.transformer === "lightningcss") {
    console.warn(
      "[vite-plugin-lib-assets]: The processing of style files using lightningcss is not yet supported by this plugin due to insufficient information. This might lead to incorrect handling of assets referenced in the @import files. https://github.com/laynezh/vite-plugin-lib-assets/issues/34#issuecomment-1826250269"
    );
    if (config.build.sourcemap === false)
      build = { ...build, sourcemap: true };
    if (!css.devSourcemap)
      css = { ...css, devSourcemap: true };
  } else {
    const { postcss = {} } = css;
    if (typeof postcss !== "string") {
      css = {
        ...css,
        postcss: {
          ...postcss,
          map: isObject(postcss.map) ? { ...postcss.map, inline: true } : { inline: true }
        }
      };
    } else {
      css = {
        ...css,
        postcss: {
          map: { inline: true }
        }
      };
    }
  }
  return { ...config, css, build };
}

// src/processStyle/utils.ts
function getAssetsInStyle(source) {
  const cssUrlAssets = getCaptured(source, cssUrlRE);
  const cssImageSetAssets = getCaptured(source, cssImageSetRE);
  const assets = [...cssUrlAssets, ...cssImageSetAssets];
  const pureAssets = assets.map(
    (asset) => asset.startsWith("'") || asset.startsWith('"') ? asset.slice(1, -1) : asset
  );
  const concernedAssets = pureAssets.filter(
    (asset) => !asset.startsWith("data:") && !/^(?:https?:)?\/\//.test(asset)
  );
  return concernedAssets;
}

// src/processStyle/index.ts
var postcssSourceMapReg = /\/\*# sourceMappingURL=data:application\/json;base64,([^*]+)\*\//mi;
function getSourceMapFromResult(result, config) {
  const css = config.css ?? {};
  if ("transformer" in css && css.transformer === "lightningcss") {
    if (typeof result.map === "string") {
      try {
        return JSON.parse(result.map);
      } catch (err) {
        return null;
      }
    }
    return result.map && "version" in result.map ? result.map : null;
  } else {
    const [_, sourceMapBase64] = result.code.match(postcssSourceMapReg) || ["", ""];
    try {
      const sourceMap = Buffer.from(sourceMapBase64.trim(), "base64").toString("utf8");
      return JSON.parse(sourceMap);
    } catch (err) {
      return null;
    }
  }
}
async function rebaseStyleUrls(moduleId, result, config) {
  const sourceMap = getSourceMapFromResult(result, config);
  if (sourceMap === null) {
    console.warn(
      "[vite-plugin-lib-assets]: Failed to obtain the sourcemap when handling the style file. This might lead to incorrect handling of assets referenced in the @import files. https://github.com/laynezh/vite-plugin-lib-assets/issues/34#issuecomment-1826250269"
    );
    return result;
  }
  if (sourceMap.sources.length < 2)
    return result;
  const moduleDir = path2.dirname(moduleId);
  const { sources, sourcesContent = [] } = sourceMap;
  const replacements = await Promise.all(
    sources.map(async (source2, index) => {
      const escaped = escapeStringRegexp2(source2);
      const testRegExp = new RegExp(`${escaped}$`);
      if (testRegExp.test(moduleId))
        return [];
      if (source2.indexOf(config.root.slice(1)) === 0)
        source2 = `/${source2}`;
      const filepath = path2.isAbsolute(source2) ? source2 : path2.resolve(moduleDir, source2);
      const fileDir = path2.dirname(filepath);
      let content = sourcesContent[index];
      if (content === null) {
        if (fs3.existsSync(filepath)) {
          content = await util.promisify(fs3.readFile)(filepath, "utf8");
        } else {
          console.warn(
            "[vite-plugin-lib-assets]: Failed to obtain the file content when handling the style file. This might lead to incorrect handling of assets referenced in the @import files. https://github.com/laynezh/vite-plugin-lib-assets/issues/34#issuecomment-1826250269"
          );
          return [];
        }
      }
      const assets = getAssetsInStyle(content);
      return assets.map((asset) => {
        const assetPath = path2.resolve(fileDir, asset);
        const replacement = path2.relative(moduleDir, assetPath);
        return { [asset]: replacement };
      });
    })
  );
  let source = result.code;
  let position = 0;
  replacements.flat().forEach((replacement) => {
    Object.keys(replacement).forEach((asset) => {
      const processed = source.slice(0, position);
      const left = source.slice(position);
      const assetIndex = left.indexOf(asset, position);
      const replaceValue = replacement[asset];
      source = processed + left.replace(asset, replaceValue);
      position = assetIndex + (replaceValue.length - asset.length);
    });
  });
  return { ...result, code: source };
}
async function processStyle(moduleId, code, config) {
  const needRebaseUrls = code.includes("@import");
  const processConfig = needRebaseUrls ? await ensureCssSourceMapConfig(config) : config;
  let result = await preprocessCSS(code, moduleId, processConfig);
  if (needRebaseUrls) {
    result = await rebaseStyleUrls(moduleId, result, config);
    result.code = result.code.replace(postcssSourceMapReg, "");
  }
  return result.code;
}

// src/index.ts
function VitePluginLibAssets(options = {}) {
  registerCustomMime();
  const {
    include = DEFAULT_ASSETS_RE,
    exclude,
    name = "[contenthash].[ext]",
    limit,
    outputPath,
    regExp,
    publicUrl = ""
  } = options;
  const pluginName = "vite-plugin-lib-assets";
  const publicDir = publicUrl.endsWith("/") ? publicUrl : `${publicUrl}/`;
  let isLibBuild = false;
  let isBuildWatch = false;
  let assetsDir;
  let outDir;
  let alias = [];
  let viteConfig;
  const descriptorOptions = {
    compiler: null,
    // to be set in buildStart
    root: process.cwd()
  };
  const filter = createFilter(include, exclude);
  const jsTypeFilter = createFilter(JS_TYPES_RE);
  const cssLangFilter = createFilter(CSS_LANGS_RE);
  const assetsImporterFilter = createFilter(ASSETS_IMPORTER_RE);
  const assetCache = /* @__PURE__ */ new Map();
  const assetsPathMap = /* @__PURE__ */ new Map();
  const base64AssetsPathMap = /* @__PURE__ */ new Map();
  const emitFile = (context, id, content) => {
    const [pureId, resourceQuery = ""] = /^([^?]+)(\?.*)?$/.exec(id).slice(1);
    const loaderContext = {
      resourcePath: pureId,
      resourceQuery
    };
    const url = interpolateName(loaderContext, name, { content, regExp });
    let assetPath = url;
    const outputDir = outputPath || assetsDir;
    assetPath = typeof outputDir === "function" ? path3.posix.join(outputDir(url, pureId, resourceQuery), url) : path3.posix.join(outputDir, url);
    const filename = assetPath.replace(resourceQuery, "");
    const fullname = path3.join(path3.isAbsolute(outDir) ? process.cwd() : "", outDir, assetPath);
    const emitted = {
      fileName: filename,
      name: fullname,
      source: new Uint8Array(content),
      type: "asset"
    };
    context.emitFile(emitted);
    if (isBuildWatch)
      assetCache.set(filename, emitted);
    return assetPath;
  };
  const extractFromJs = async (context, id, content) => {
    const newUrlAssets = getCaptured(content, assetImportMetaUrlRE);
    const staticAssets = newUrlAssets.filter(
      (asset) => !(asset[0] === "`" && asset.includes("${"))
    );
    const pureAssets = staticAssets.map((asset) => asset.slice(1, -1));
    const concernedAssets = pureAssets.filter(
      (asset) => !asset.startsWith("data:") && !/^(?:https?:)?\/\//.test(asset)
    );
    return resolve(context, alias, Array.from(new Set(concernedAssets)), id);
  };
  const extractFromCss = async (context, id, content) => {
    let source = content;
    try {
      source = await processStyle(id, content, viteConfig);
    } catch (err) {
      console.warn(`[vite-plugin-lib-assets]: failed to preprocessCSS ${err}`);
    }
    const cssUrlAssets = getCaptured(source, cssUrlRE);
    const cssImageSetAssets = getCaptured(source, cssImageSetRE);
    const assets = [...cssUrlAssets, ...cssImageSetAssets];
    const pureAssets = assets.map(
      (asset) => asset.startsWith("'") || asset.startsWith('"') ? asset.slice(1, -1) : asset
    );
    const concernedAssets = pureAssets.filter(
      (asset) => !asset.startsWith("data:") && !/^(?:https?:)?\/\//.test(asset)
    );
    return resolve(context, alias, Array.from(new Set(concernedAssets)), id);
  };
  const extractFromFile = async (context, id) => {
    const content = getAssetContent(id);
    if (!content)
      return [];
    const [pureId] = id.split("?", 2);
    if (path3.extname(pureId) === ".vue") {
      if (!descriptorOptions.compiler)
        descriptorOptions.compiler = resolveCompiler(descriptorOptions.root);
      const descriptor = getDescriptor(pureId, descriptorOptions);
      if (descriptor === void 0)
        return [];
      let extractedAssetList = [];
      if (jsTypeFilter(id)) {
        extractedAssetList = await Promise.all(
          [descriptor.scriptSetup, descriptor.script].filter((script) => {
            return script && script.content.includes("new URL") && script.content.includes("import.meta.url");
          }).map((script) => extractFromJs(context, id, script.content))
        );
      } else {
        extractedAssetList = await Promise.all(
          descriptor.styles.map(
            (style) => extractFromCss(context, id, style.content)
          )
        );
      }
      return extractedAssetList.flatMap((extractedAssets) => extractedAssets);
    }
    return jsTypeFilter(id) ? extractFromJs(context, id, content.toString()) : extractFromCss(context, id, content.toString());
  };
  const processAssetsInBase64 = (bundleSourceMap) => {
    const updatedSourceMap = { ...bundleSourceMap };
    Object.keys(updatedSourceMap).forEach((name2) => {
      let updated = updatedSourceMap[name2];
      base64AssetsPathMap.forEach((asset, base64) => {
        updated = replaceAll(updated, base64, publicUrl ? asset : `./${asset}`);
      });
      if (updatedSourceMap[name2] !== updated)
        updatedSourceMap[name2] = updated;
    });
    return updatedSourceMap;
  };
  const processAssetsInImporters = (bundleSourceMap) => {
    const updatedSourceMap = { ...bundleSourceMap };
    const assetsExtracted = Object.keys(updatedSourceMap).filter((id) => filter(id));
    Object.keys(updatedSourceMap).filter((name2) => assetsImporterFilter(name2)).forEach((name2) => {
      let updated = updatedSourceMap[name2];
      const fileDir = path3.dirname(name2);
      assetsExtracted.forEach(async (asset) => {
        const relativePath = path3.posix.relative(fileDir, asset);
        const relativeAsset = relativePath.startsWith(".") ? relativePath : `./${relativePath}`;
        const originalAsset = `./${asset}`;
        if (asset !== relativeAsset && updated.includes(originalAsset)) {
          updated = replaceAll(updated, `'${originalAsset}'`, `'${relativeAsset}'`);
          updated = replaceAll(updated, `"${originalAsset}"`, `"${relativeAsset}"`);
          updated = replaceAll(updated, `(${originalAsset})`, `(${relativeAsset})`);
        }
      });
      if (updatedSourceMap[name2] !== updated)
        updatedSourceMap[name2] = updated;
    });
    return updatedSourceMap;
  };
  return {
    name: pluginName,
    apply: "build",
    enforce: "pre",
    configResolved(config) {
      viteConfig = config;
      isBuildWatch = !!config.build.watch;
      const { build, resolve: resolve2 } = config;
      isLibBuild = build.lib !== false;
      assetsDir = build.assetsDir;
      outDir = build.outDir;
      alias = resolve2.alias;
      if (build.lib !== false) {
        const { formats = ["es", "umd"] } = build.lib;
        const valid = checkFormats(formats);
        if (!valid && publicUrl) {
          console.warn(
            "[vite-plugin-lib-assets] The publicUrl configuration will be applied to all output formats."
          );
        }
      }
    },
    async resolveId(source, importer = "", opts) {
      if (!isLibBuild)
        return null;
      if (checkPublicAsset(source, viteConfig.publicDir))
        return null;
      if (opts.custom?.[pluginName]?.fromResolveId)
        return null;
      let id;
      if (path3.isAbsolute(source)) {
        id = source;
      } else if (source.startsWith(".")) {
        id = path3.resolve(path3.dirname(importer), source);
      } else {
        const custom = { ...opts.custom, [pluginName]: { fromResolveId: true } };
        const resolved = await this.resolve(source, importer, { ...opts, custom });
        if (resolved === null)
          return null;
        id = resolved.id;
      }
      if (jsTypeFilter(id) || cssLangFilter(id)) {
        const assetsExtracted = await extractFromFile(this, id);
        const validAssets = assetsExtracted.map((aid) => path3.resolve(path3.dirname(id), aid)).filter((id2) => filter(id2)).map((id2) => ({ id: id2, content: getAssetContent(id2) })).filter(({ content }) => limit && content ? content.byteLength > limit : true);
        validAssets.forEach(({ id: id2, content }) => {
          let assetPath = emitFile(this, id2, content);
          const base64 = getFileBase64(id2, content);
          if (publicUrl)
            assetPath = `${publicDir}${assetPath}`;
          base64AssetsPathMap.set(base64, assetPath);
        });
      }
      if (filter(id)) {
        const content = getAssetContent(id);
        if (!content)
          return null;
        if (limit && content.byteLength < limit)
          return null;
        const assetPath = emitFile(this, id, content);
        if (publicUrl) {
          assetsPathMap.set(id, assetPath);
          return id;
        }
        return {
          id: `./${assetPath}`,
          external: "relative"
        };
      }
    },
    load(id) {
      if (!isLibBuild)
        return null;
      const assetPath = assetsPathMap.get(id);
      if (assetPath)
        return `export default '${publicDir}${assetPath}'`;
    },
    async writeBundle(_, outputBundle) {
      const outputDir = path3.isAbsolute(outDir) ? outDir : path3.posix.join(process.cwd(), outDir);
      const bundleSourceMap = Object.keys(outputBundle).reduce((map, name2) => {
        const filePath = path3.posix.join(outputDir, name2);
        const source = fs4.readFileSync(filePath, "utf8");
        map[name2] = source;
        return map;
      }, {});
      const cacheSourceMap = isBuildWatch ? Object.values(Object.fromEntries(assetCache)).reduce((map, { fileName, source }) => {
        if (fileName && source && !bundleSourceMap[fileName])
          map[fileName] = String(source);
        return map;
      }, {}) : {};
      const updatedSourceMap = processAssetsInBase64({ ...bundleSourceMap, ...cacheSourceMap });
      const processedSourceMap = processAssetsInImporters(updatedSourceMap);
      Object.keys(bundleSourceMap).filter((name2) => bundleSourceMap[name2] !== processedSourceMap[name2]).forEach((name2) => {
        const outputPath2 = path3.posix.join(outputDir, name2);
        const updated = processedSourceMap[name2];
        fs4.writeFileSync(outputPath2, updated);
        const bundle = outputBundle[name2];
        if (bundle.type === "chunk")
          bundle.code = updated;
        else if (name2.endsWith(".css"))
          bundle.source = updated;
      });
      Object.keys(cacheSourceMap).forEach((name2) => {
        const outputPath2 = path3.posix.join(outputDir, name2);
        const updated = cacheSourceMap[name2];
        fs4.writeFileSync(outputPath2, updated);
      });
    }
  };
}
export {
  VitePluginLibAssets as default
};
